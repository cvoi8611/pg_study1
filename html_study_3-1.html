<!DOCTYPE HTML>	
<html>
    <head>
        <meta charset="UTF-8">
        <title> 스터디 html 정리 3주차 - 1 </title>
    </head>
    <body>
        <h1>하계 방학 스터디 3주차 html 단어정리 - 1</h1>
        
        <h2>1. GO 언어</h2>
        <p><b>2009년 11월 구글에서 최초로 발표, 이후 2012년 3월에 정식 발표된 프로그래밍 언어</b></p>
        <p>Go 언어는 컴파일 언어지만 컴파일러의 컴파일 속도가 매우 빨라 인터프리터 언어처럼 쓸 수 있다는 점이 있다</p>
        <p>장점으로는 매우 빠른 컴파일 속도로, 인터프리터의 빠른 속도와, 컴파일 언어의 실행 시 퍼포먼스를 둘 다 챙길 수 있다</p>
        <p>그리고 GoRoutine 이라는 비동기 메커니즘을 제공하는데 이 고루틴은 각각의 고루틴을 병렬로 동작하여, 이벤트 처리 및 병렬 프로그래밍을 가능하게 함, 심지어 고루틴은 멀티스레드 매커니즘임에도 불구하고, 자체적인 스케줄러에 의해 관리되는 경량 스레드이고, OS에서 관리하는 경량 스레드보다 더 경량이다</p>
        <p>그러나 단점으로는 바이트코드를 생성하는 언어가 아니므로, 바이너리만 배포할 경우 해당 타깃 머신에 맞춰서 각각 컴파일해야 한다. 그렇게 하지 않고서 다중 플랫폼을 지원하려면 소스 코드째로 배포해야 한다.</p>
        <p>GO 언어는 'GO'라는 이름으로 검색하기엔 쓰이는 단어가 존재해서 보통 Golang 으로 검색하거나 발음한다</p>
        <p>GO 언어 사용자들을 고퍼(Gopher) 이라고 하며, 이러한 고퍼들을 위한 연례행사인 고퍼콘(GopherCon)이 세계 각국에서 매년 열림</p>


        <h2>2. RUST 언어</h2>
        <p><b>러스트 재단에서 개발되고 있는 메모리 안전성과 성능 및 편의성에 중점을 둔 프로그래밍 언어</b></p>
        <p>가비지 컬렉터 없이 메모리 안전성을 제공하는 대표적인 언어로, C++의 대체재로써 등장했다.</p>
        <p>이 언어는 모질라 재단에서 2010년 7월 7일 처음 발표했으며, 2015년 5월 15일 안정 버전이 정식 발표되었다.</p>
        <p>Rust 언어는 현대적인 시스템 프로그래밍 언어로 C/C++과 동등한 수준의 속도를 유지하면서 안전성&동시성을 향상시키는 것을 목표로 설계되었다.</p>
        <p>이 언어의 특징으로는 안전한 메모리를 관리하기 위해, 무분별한 참조를 막는 제약이 존재하고, 안전성과 성능을 고려하기 위해 소유권(ownership)과, 수명 파라메터(lifetime parameter)라는 개념이 존재한다.</p>
        <ul>
            <li><p>소유권(ownership) : 객체의 생성과 소멸을 관리하기 위한 개념</p></li>
            <li><p>수명 파라메터(lifetime parameter) : 컴파일러가 참조자의 유효성을 검증할 수 있도록 하기 위한 개념</p></li>
        </ul>
        <p>그리고 모든 변수의 가변성을 명확하게 컴파일 타임에 구분한다는 특징이 있다.</p>
        <p>또, 비동기 프로그래밍을 지원하고 있다.</p>
        <p>추가로 C++, C#, Java 등 대중적인 정적 타입 프로그래밍 언어들에서 흔히 제공되는 일반화 프로그래밍 (Generic Programming) 패러다임을, 제네릭이라는 기능으로 제공한다.</p>
        <p>개발자들 사이에서 배우고 싶은 언어로 상위권에 랭크할 정도로 많은 관심을 받고 있다.</p>


        <h2>3. gdb</h2>
        <p><b>GDB(GNU Debugger)는 GNU 소프트웨어 시스템을 위한 기본 디버거</b></p>
        <p>1988년 리처드 스톨만이 처음 작성하였고, 컴퓨터 프로그램의 실행을 추적하고 수정할 수 있는 많은 기능들을 제공한다.</p>
        <p>이러한 기능들은 매우 많기 때문에 축약한다면</p>
        <ul>
            <li><p>프로그램을 시작, 프로그램의 동작에 영향을 줄 수 있는 것을 지정</p></li>
            <li><p>지정된 조건에서 프로그램 중지</p></li>
            <li><p>프로그램이 중지 되었을 떄, 어떤 일이 벌어졌는 지 확인</p></li>
            <li><p>프로그램의 내용을 변경하여 버그를 수정 및 다른 버그에 대해 알아보는 실험을 계속 할 수 있음</p></li>
        </ul>
        <p>이렇게 4가지로 요약이 가능하다.</p>


        <h2>4. scanf의 문자열 매칭</h2>
        <p><b>scanf에서 문자열을 매칭시킬때 사용되는 포맷(형식)들</b></p>
        <ul> Example Format
            <ul><li><p><b>%[문자열A]</b> : 전달 받은 문자열이 문자열A에 해당되는 문자열이면, 입력 받음 or 아니면? -> 입력받기 중단</p></li></ul>
            <ul><li><p><b>%[ab]</b> : 전달받은 문자열 = ababc 이면 abab 입력받고 c에서 자름</p></li></ul>
            <ul><li><p><b>%[a-c]</b> : 전달 받을 수 있는 문자열 a~c 즉, a,b,c</p></li></ul>
            <ul><li><p><b>%[a-cd1-3]</b> : a~d , 1~3</p></li></ul>
            <ul><li><p><b>%[^\r\n]</b> : 개행, 리턴 문자 입력받기 전까지의 모든 문자열</p></li></ul>
        </ul>
        <p>위와 같이 scanf의 문자열 매칭은 []안에 해당되는 문자열이 입력받는 동안에는 계속해서 scanf를 통해 문자열을 가져오는 방식이고, [] 안에서는 정규 표현식으로도 표현이 가능하다는 특징이 있다.</p>
        
        
        <h2>5. C언어 헤더 파일</h2>
        <p><b>헤더 파일이란 주로 외부 소스 파일에 정의된 변수나 함수를 쓰기 위해 만들어 진 C, C++에서 사용하는 일종의 레퍼런스</b></p>
        <p>간단하게 비유하자면 메뉴판이다.</p>
        <p>음식 메뉴들이 함수들이고, 음식 메뉴들을 보기 편하게 모아둔 메뉴판처럼 많은 양의 함수들을 모아서 정리해 둔 것이 헤더파일이다.</p>
        <p> 즉, <b>음식 메뉴 : 함수 = 메뉴판 : 헤더 파일</b></p>
        <p>기본적으로 제공하는 헤더파일을 표준 라이브러리라고 하는데 예시로는 C에서는 입/출력 함수를 가진 stdio, 시간 관련 부분함수를 담고 있는 time, 또는 수학 관련 함수를 포함한 math 등이 있다.</p>
        <p>C++ 에서는 stdio를 쓰는 C와 다르게 iostream을 사용한다</p>
        
        
        <h2>6. fopen & freopen</h2> 
        <p><b>C, C++언어에서 파일 입/출력을 가능하게 하는 함수</b></p>
        <p>* 스트림이란?</p>
        <p>스트림은 일반적으로 데이터, 패킷, 비트 등의 일련의 연속성을 갖는 흐름을 의미함</p>
        <p>이러한 스트림은 마치 '추상화된 장치'라고 비유할 수 있다 즉, 주변 장치들 (ex. 모니터, 키보드, HDD)을 추상화 시켜서 마치 동일한 장치에 접근하는 것 처럼 사용될 수 있음</p>
        <p>헤더 파일 C - stdio.h , C++ - cstdio</p>
        <p>fopen - 파일을 열어주는 함수</p>
        <p>fopen 함수 원형</p>
        <p><b>fopen ([fileName] ,[fileMode])</b></p>
        <ul>
            <li><p>fileName : 파일 이름</p>
                <ul><p>파일의 이름 (경로 포함)</p></ul>
            </li>
            <li><p>fileMode : 파일 모드</p>
                <ul><p>파일을 어떻게 open할 것인지에 대한 인자</p>
                    <li><p>'r' : read mode</p><p>파일을 읽는 것만 가능, 해당 파일이 존재하면 파일을 열고 존재하지 않으면 에러 반환</p></li>
                    <li><p>'w' : write mode</p><p>파일을 열어서 편집, 해당 파일이 존재하면 파일을 열고 존재하지 않으면 파일 생성</p></li>
                    <li><p>'a' : append mode</p><p>읽기,쓰기 기능, 해당 파일이 존재하면 파일을 열고 존재하지 않으면 파일 생성</p></li>
                    <li><p>'r+' : read+ mode</p><p>읽기,쓰기 기능, 해당 파일이 존재하면 파일을 열고 존재하지 않으면 에러 반환</p></li>
                    <li><p>'w+' : write+ mode</p><p>읽기,쓰기 기능, 해당 파일이 존재하면 파일을 열고 존재하지 않으면 파일 새로 생성</p></li>
                    <li><p>'a+' : append+ mode</p><p>읽기,쓰기 기능, 해당 파일이 존재하면 파일을 열고 존재하지 않으면 파일 새로 생성</p></li>
                </ul>
            </li>
        </ul>
        
        <p>freopen - 스트림을 다른 파일이나 방식(mode)으로 다시 여는 함수</p>
        <p><b>freopen ([fileName] ,[fileMode] ,[fileStream])</b></p>
        <ul>
            <li><p>fopen과 유사하나, fileStream 에서 해당되는 Stream으로 바꿔서 파일을 염</p></li>
        </ul>

        <p>용도는?</p>
        <p>fopen으로도 충분히 파일을 읽고 쓰는 작업을 수행할 수는 있다.</p>
        <p> freopen을 사용하면, output으로 printf와 같은 출력 함수가 아닌 어떠한 파일 하나를 출력물로 제출해야 할떄 freopen을 사용하여 fileStream을 변경하면 구현이 가능하다.</p>
        
        
        <h2>7. C++의 cout, cin 과 C의 printf, scanf와의 차이</h2>
        <p><b>C++ , C 의 입/출력 함수</b></p>
        <p>C++의 cout, cin의 헤더파일 - iostream</p>
        <p>C의 printf, scanf 의 헤더파일 - stdio.h</p>
        <p>C++의 cin,cout은 주로 백준 문제에서 시간 초과가 자주 일어남, why?</p>
        <p>-> 속도가 매우 느리기 떄문</p>
        
        
        <h2>8. 포인터(*)와 참조(&)의 차이</h2>
        <p><b>포인터와 참조자는 모두 함수 내에서 변수의 값을 변경이 가능</b></p>
        <ul> 포인터 (Pointer)
            <li><p>선언 시 주소를 할당 할 필요가 없음, 나중에 다른 주소를 할당 가능</p></li>
            <li><p>함수로 넘어가면 새로운 포인터에 포인터의 주소를 복사하기 때문에 메모리가 필요함</p></li>
            <li><p>변수를 바꾸기 위해 * 연산자를 사용</p></li>
        </ul>
        <ul> 참조자 (Reference)
            <li><p>선언 시 반드시 처음에 변수를 할당하고, 나중에 변경이 가능</p></li>
            <li><p>함수에서는 이름만 빌려가기 때문에 메모리가 따로 필요하지 않음</p></li>
            <li><p>변수의 이름을 바꿀땐, 문제가 없으므로 이름만 바꾸면 됨</p></li>
        </ul>
        <p>보통 포인터의 주소를 참조자에 담아서 사용한다</p>
        

        <h2>9. 함수 포인터와 람다(익명) 함수</h2>
        <p><b>람다 함수는 익명 함수(Anonymous functions)를 지칭하는 은어</b></p>
        <p><b>함수 포인터는 말 그대로, 함수를 가리키는 포인터</b></p>

        <p>람다 표현식을 동일한 형식의 함수 포인터에 대입하면 사용 가능</p>


        <p>람다를 함수 포인터처럼 사용이 가능하나, 캡처를 사용한 람다(외부에 정의된 상수 또는 변수를 가져오는 람다)는 변환이 불가능함</p>

        <h2>10. 콜백 함수와 콜백 지옥</h2>
        <p><b>콜백 함수 - 다른 함수가 실행을 끝낸 뒤 특정 이벤트에 의해 실행되는 함수</b></p>
        <p><b>콜백 지옥 - 콜백 함수를 익명 함수로 전달하는 과정에서 또 다시 콜백 안에 함수 호출이 반복되어 코드의 들여쓰기 수준이 점점 깊어져서 가독성을 크게 해치는 현상</b></p>
        <p>콜백 함수는 보통 JavaScript에서 주로 쓰이며, 콜백 함수의 장점은 코드를 재사용할때 나타난다</p>
        <p>콜백 함수는 함수 내에서 해야 할 일을 콜백 함수를 통해 추상화하여 전달받아, 코드의 가변성과 확장성을 가진다.</p>

        <p>예시 ↓</p>
        <img src="https://cdn.discordapp.com/attachments/450315092190429187/1130746779244183634/image.png" style="width:600px; height:300px;">
        <p>위 예시 코드를 보면 보기에도 어지럽고 읽기도 불편한데다, 코드의 흐름을 따라가보는 것도 어려워보이며, 만약 수정할 일이 생기면 수정도 쉽지 않아 보인다.</p>
        <p>위와 같은 코드는 콜백 함수 내에 콜백 함수가 여러번 반복되어 콜백 함수가 여러 번 중첩되는 경우이며,</p>
        <p>이런 코드는 가독성이 매우 떨어져 이를 수정하거나 읽을 떄 큰 문제가 되는데 이를 '콜백 지옥'이라고 부른다.</p>
        <p>해결 방법</p>
        <p>콜백 지옥을 해결하기 위한 대체 방법으로는 새로운 라이브러리 함수를 만들어, 적당한 동기 신호를 통해 필요한 처리만을 하게끔 코드를 다시 짠다.</p>


    </body>
</html>